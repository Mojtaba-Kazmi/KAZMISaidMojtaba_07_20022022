{"version":3,"sources":["auth.js"],"names":["jwt","require","queryDbb","module","exports","req","res","next","headers","authorization","status","json","message","split","scheme","token","toLowerCase","jwtToken","verify","userId","userIsAdmin","isAdmin","insert","selectIdFromUser","result","error","user"],"mappings":";;;;;;;;;;AAAA,IAAMA,GAAG,GAAGC,OAAO,CAAC,cAAD,CAAnB;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,aAAD,CAAxB,C,CAGA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,iBAAOC,GAAP,EAAYC,GAAZ,EAAiBC,IAAjB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAET;AACQC,UAAAA,OAHC,GAGWH,GAHX,CAGDG,OAHC;;AAAA,gBAIL,CAACA,OAAD,IAAY,CAACA,OAAO,CAACC,aAJhB;AAAA;AAAA;AAAA;;AAAA,2CAKAH,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,YAAAA,OAAO,EAAE;AADiB,WAArB,CALA;;AAAA;AAUT;AAVS,kCAWeJ,OAAO,CAACC,aAAR,CAAsBI,KAAtB,CAA4B,GAA5B,CAXf,qEAWFC,MAXE,8BAWMC,KAXN;;AAAA,gBAaL,CAACD,MAAD,IAAWA,MAAM,CAACE,WAAP,OAAyB,QAApC,IAAgD,CAACD,KAb5C;AAAA;AAAA;AAAA;;AAAA,2CAcAT,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,YAAAA,OAAO,EAAE;AADiB,WAArB,CAdA;;AAAA;AAmBT;AACMK,UAAAA,QApBG,GAoBQjB,GAAG,CAACkB,MAAJ,CAAWH,KAAX,EAAkB,qBAAlB,CApBR,EAqBT;;AACMI,UAAAA,MAtBG,GAsBMF,QAAQ,CAACE,MAtBf;AAuBHC,UAAAA,WAvBG,GAuBWH,QAAQ,CAACI,OAvBpB;AAyBHC,UAAAA,MAzBG,GAyBM,CAACH,MAAD,CAzBN;AAAA;AAAA,0CA0BYjB,QAAQ,CAACqB,gBAAT,CAA0BD,MAA1B,CA1BZ;;AAAA;AA0BHE,UAAAA,MA1BG;AAAA;;AAAA,cA6BFA,MAAM,CAAC,CAAD,CA7BJ;AAAA;AAAA;AAAA;;AAAA,2CA8BElB,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAACc,YAAAA,KAAK,EAAE;AAAR,WAArB,CA9BF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,2CAiCAnB,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAACc,YAAAA,KAAK,EAAE;AAAR,WAArB,CAjCA;;AAAA;AAqCT;AACApB,UAAAA,GAAG,CAACqB,IAAJ,GAAWP,MAAX;AACAd,UAAAA,GAAG,CAACe,WAAJ,GAAkBA,WAAlB,CAvCS,CAyCT;;AAzCS,2CA0CFb,IAAI,EA1CF;;AAAA;AAAA;AAAA;AAAA,2CA4CFD,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,YAAAA,OAAO,EAAE;AADiB,WAArB,CA5CE;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAjB","sourcesContent":["const jwt = require('jsonwebtoken');\nconst queryDbb = require('../queryBdd');\n\n\n//middleware qui vérifie le token de l'utilisateur\nmodule.exports = async (req, res, next) => {\n   try {\n        // On vérifie que le header Authorization est présent dans la requete\n        const { headers } = req;\n        if (!headers || !headers.authorization) {\n          return res.status(401).json({\n            message: 'Missing Authorization header'\n          });\n        }\n\n        //on vérifie que le header Authorization contient bien le token\n        const [scheme, token] = headers.authorization.split(' ');\n\n        if (!scheme || scheme.toLowerCase() !== 'bearer' || !token) {\n          return res.status(401).json({\n            message: 'Header format is Authorization: Bearer token'\n          });\n        }\n\n        //on vérifie et décode le token à l'aide du secret \n        const jwtToken = jwt.verify(token, 'RANDOM_TOKEN_SECRET');\n        //on vérifie que l'utilisateur existe dans la base de donnée\n        const userId = jwtToken.userId;\n        const userIsAdmin = jwtToken.isAdmin;\n\n        const insert = [userId]\n        const result = await queryDbb.selectIdFromUser(insert);\n        \n        try {\n          if (!result[0]) {\n            return res.status(400).json({error: 'l\\'utilisateur n\\'existe pas.'});\n          } \n        } catch (err) {\n          return res.status(500).json({error: \"mysql2\"});\n        }\n        \n\n        //On passe l'utilisateur dans notre requete afin que celui-ci soit disponible pour les prochains middlewares\n        req.user = userId;\n        req.userIsAdmin = userIsAdmin\n\n        //On appelle le prochain middleware\n        return next();\n    } catch (err) {    \n        return res.status(401).json({\n          message: 'Invalid token'\n        });    \n    }\n};\n\n\n\n"],"file":"auth.dev.js"}